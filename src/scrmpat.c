/**
@file scrmpat.c
@page scrmpat
@brief Tabulate site pattern frequencies from .daf files.

# Scrmpat: tabulates site patterns

Scrmpat reads data generated by scrm (with option -transpose-segsites)
tabulates counts of nucleotide site patterns, writing the result to
standard output.

# Usage

    Usage: scrmpat [options] <x> <y> ...
      where <x>, <y>, etc. are arbitrary labels, whose number and order
      must agree with that of the populations specified in the scrm command
      line (using scrm arguments -I and -eI). Labels may not include the
      character ":". Reads standard input; writes to standard
      output. Max number of input files: 32.

    Options may include:
       -F or --logFixed
          log fixed sites to scrmpat.log
       -a or --logAll
          log all sites to scrmpat.log
       --version
          Print version and exit
       -h or --help
          Print this message

# Example

`scrmpat` parses a file generated using `scrm`. The `scrm` command
should include the option `-transpose-segsites`. Let us assume you
have done this, that file `foo.scrm` contains the output simulated
by `scrm`, and that these simulated data included genotypes referring
to four populations, labeled "x", "y", "n", and "d". The `scrmpat`
command would look like this:

    scrmpat --infile foo.scrm x y n d

`scrmpat`'s notion of a "population" differs from that of `scrm`, in
that `scrmpat` treats samples of different ages as separate
populations, even if they reside in the same population on the `scrm`
command line. For example, consider the following `scrm` command line:

    scrm 3 -I 2 1 1 -eI 0.5 0 1

This specifies three haploid samples distributed across two
populations. The `-I` argument says that each population has a
sample at time 0. The `-eI` argument says that, in addition,
population 2 has a sample at time 0.5. All three samples would be
treated as separate populations by `scrmpat`. Thus, the `scrmpat`
command line should list three labels, as in "scrmpat x y z".

In the output, site pattern "x:y" refers to
the pattern in which the derived allele is present haploid samples
from "x" and "y" but not on those from other populations. The order of
the command-line arguments determines the order in which labels are
sorted on output. Given the command line above, we would get a site
pattern labeled "x:y:d" rather than, say, "y:x:d".

The output looks like this:

    # scrmpat version 1.3
    # Population labels: x y n d
    # Number of site patterns: 10
    # Tabulated 12327755 SNPs
    #       SitePat             E[count]
                x:y       340952.4592501
                x:n        46874.1307236
                x:d        46034.4670204
                y:n        55137.4236715
                y:d        43535.5248078
                n:d       231953.3372578
              x:y:n        91646.1277991
              x:y:d        88476.9619569
              x:n:d        96676.3877423
              y:n:d       100311.4411513

The left column lists the site patterns that occur in the data. The
right column gives the expected count of each site pattern. These are
not integers, because they represent averages over all possible
subsamples consisting of a single haploid genome from each
population.

@copyright Copyright (c) 2018, Alan R. Rogers
<rogers@anthro.utah.edu>. This file is released under the Internet
Systems Consortium License, which can be found in file "LICENSE".
*/

#include "binary.h"
#include "misc.h"
#include "scrmreader.h"
#include "typedefs.h"
#include "error.h"
#include <ctype.h>
#include <errno.h>
#include <getopt.h>
#include <gsl/gsl_rng.h>
#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

typedef struct Stack Stack;

/// Treat a vector of tipId_t values as a push-down stack.
struct Stack {
    int         dim, nused;
    tipId_t    *buff;           // not locally owned
};

static void usage(void);
static Stack *Stack_new(int dim, tipId_t buff[dim]);
static void Stack_free(Stack * stk);
static void Stack_push(Stack * self, tipId_t x);
static void generatePatterns(int bit, int npops, Stack * stk, tipId_t pat,
                             int doSing);

const char *useMsg =
    "\nUsage: scrmpat [options] <x> <y> ...\n"
    "  where <x>, <y>, etc. are arbitrary labels, whose number and order\n"
    "  must agree with that of the populations specified in the scrm command\n"
    "  line (using scrm arguments -I and -eI). Labels may not include the\n"
    "  character \":\". Writes to standard output.";

/// Print usage message and die.
static void usage(void) {
    fputs(useMsg, stderr);
    fputs("\nOptions may include:\n", stderr);
    tellopt("-F or --logFixed", "log fixed sites to scrmpat.log");
    tellopt("-a or --logAll", "log all sites to scrmpat.log");
    tellopt("--version", "Print version and exit");
    tellopt("-h or --help", "Print this message");
    exit(1);
}

/// This stack is local to this file. It provides a bounds-controlled
/// interface to an external array, which is passed as an argument, buff,
/// to Stack_new.
static Stack *Stack_new(int dim, tipId_t buff[dim]) {
    Stack      *self = malloc(sizeof(Stack));
    CHECKMEM(self);
    self->dim = dim;
    self->buff = buff;
    self->nused = 0;
    return self;
}

/// Frees the stack but not the underlying buffer.
static void Stack_free(Stack * stk) {
    free(stk);
}

/// Add an entry to the tail of the stack, checking bounds.
static void Stack_push(Stack * self, tipId_t x) {
    if(self->nused == self->dim) {
        fprintf(stderr, "%s:%s:%d ERR: buffer overflow\n",
                __FILE__, __func__, __LINE__);
        exit(EXIT_FAILURE);
    }
    self->buff[self->nused++] = x;
}

/// Call as generatePatterns(0, npops, stk, 0); Recursive function,
/// which generates all legal site patterns and pushes them onto a
/// stack.
static void
generatePatterns(int bit, int npops, Stack * stk, tipId_t pat, int doSing) {
    assert(sizeof(tipId_t) < sizeof(unsigned long long));
    if(bit == npops) {
        // Recursion stops here. If current pattern is
        // legal, then push it onto the stack. Then return.

        // Exclude patterns with all bits on, or all bits off.
        if(pat == 0 || pat == (1ULL << npops) - 1ULL)
            return;
        // Exclude singleton patterns unless "doSing" is true.
        if(!doSing && isPow2(pat))
            return;
        Stack_push(stk, pat);
        return;
    }
    tipId_t     on = 1UL << bit;
    generatePatterns(bit + 1, npops, stk, pat | on, doSing);    // curr bit on
    generatePatterns(bit + 1, npops, stk, pat, doSing); // curr bit off
}

int main(int argc, char **argv) {
    int         i, j, status, optndx, done;
    int         doSing = 1;     // nonzero means use singleton site patterns
    char        errbuff[100] = { '\0' };
    const char *logfname = "scrmpat.log";
    int         logFixed = 0, logAll = 0;
    FILE       *logfile = NULL;

    static struct option myopts[] = {
        // {char *name, int has_arg, int *flag, int val}
        {"logFixed", no_argument, 0, 'F'},
        {"logAll", no_argument, 0, 'a'},
        {"help", no_argument, 0, 'h'},
        {"version", no_argument, 0, 'V'},
        {NULL, 0, NULL, 0}
    };

    // command line arguments
    for(;;) {
        i = getopt_long(argc, argv, "ac:ht:Fv", myopts, &optndx);
        if(i == -1)
            break;
        switch (i) {
        case ':':
        case '?':
            usage();
            break;
        case 'h':
            usage();
            break;
        case 'V':
            printf("scrmpat version %s\n", GIT_VERSION);
            return 0;
        case 'F':
            logFixed = 1;
            break;
        case 'a':
            logAll = 1;
            break;
        default:
            usage();
        }
    }

    // remaining options: population labels
    int         n = argc - optind;  // number of population labels
    if(n == 0)
        usage();

    char       *poplbl[n];
    LblNdx      lndx;
    LblNdx_init(&lndx);

    // Number of inputs can't exceed number of bits in an object of
    // type tipId_t.
    if(n > 8 * sizeof(tipId_t)) {
        fprintf(stderr, "Error: %d populations. Max is %lu.\n",
                n, 8 * sizeof(tipId_t));
        usage();
    }
    // Parse remaining arguments, each of which should be an arbitrary
    // label.
    for(i = 0; i < n; ++i) {
        poplbl[i] = argv[i + optind];
        if(poplbl[i] == NULL
           || strlen(poplbl[i]) == 0
           || strchr(poplbl[i], ':') != NULL)
            usage();
        LblNdx_addSamples(&lndx, 1, poplbl[i]);
    }

    if(logFixed || logAll) {
        logfile = fopen(logfname, "w");
        if(logfile == NULL) {
            fprintf(stderr, "Can't write to file \"%s\".\n", logfname);
            exit(EXIT_FAILURE);
        }
    }

    printf("# scrmpat version %s\n", GIT_VERSION);
    printf("# Population labels:");
    for(i = 0; i < n; ++i)
        printf(" %s", poplbl[i]);
    putchar('\n');

    // make sure labels are all different
    for(i = 1; i < n; ++i)
        for(j = 0; j < i; ++j)
            if(0 == strcmp(poplbl[i], poplbl[j])) {
                fprintf(stderr, "ERR: duplicate labels on command line.\n");
                fprintf(stderr, "     duplicated label: %s\n", poplbl[i]);
                exit(EXIT_FAILURE);
            }

    unsigned long npat = (1UL << n) - 2UL;  // number of site patterns
    if(!doSing)
        npat -= n;
    printf("# %s singleton site patterns.\n",
           (doSing ? "Including" : "Excluding"));
    printf("# Number of site patterns: %lu\n", npat);
    tipId_t     pat[npat];
    double      patCount[npat];
    int         lblsize = 100;
    char        lblbuff[lblsize];
    memset(patCount, 0, sizeof(patCount));

    {
        // Stack is a interface to array "pat".
        Stack      *stk = Stack_new(npat, pat);

        // Put site patterns into array "pat".
        generatePatterns(0, n, stk, 0, doSing);

        Stack_free(stk);
    }

    // Sort site patterns. Major sort is by number of "on" bits,
    // so that singleton patterns come first, then doubletons, etc.
    // Secondary sort is by order in which labels are listed
    // on the command line.
    qsort(pat, (size_t) npat, sizeof(pat[0]), compare_tipId);
    fflush(stdout);

    ScrmReader *r=ScrmReader_new(stdin);
    if(r == NULL) {
        fprintf(stderr,"%s:%d: Can't read scrm output\n",
                __FILE__,__LINE__);
        exit(EXIT_FAILURE);
    }
    if(n != ScrmReader_sampleDim(r)) {
        fprintf(stderr,"%s:%d:"
                " Number (%d) of labels != dimension (%d) of sample array\n"
                "in scrm output.\n",
                __FILE__,__LINE__,n,ScrmReader_sampleDim(r));
        exit(EXIT_FAILURE);
    }

    // Read the data to get dimensions. nchr=1 by fiat: rather than
    // treating the independent replicates produced by scrm as
    // separate chromosomes, I concatenate them all into a single
    // chromosome and do a moving-blocks bootstrap on that. This
    // is because in simulations, chromosomes are often pretty short,
    // and the number of chromosomes is large. I'm afraid that a
    // moving-blocks bootstrap on short chromosomes would be poorly
    // behaved. So this code sets nchr=1, calculates the total number
    // of snps, and then uses these dimensions to allocate a bootstrap
    // object.

    unsigned long nsites = 0, nbadaa = 0, nfixed = 0;
    long snpndx = -1;

    // Read data
    fprintf(stderr,
            "Doing single pass through data to tabulate patterns..\n");
    done=0;
    while(!done) {
        status = ScrmReader_next(r);
        switch(status) {
        case 0:
            ++nsites;
            break;
        case EOF:
            done=1;
            continue;
        case ALLELE_MISMATCH:
        case NO_ANCESTRAL_ALLELE:
            ++nbadaa;
            ++nsites;
            continue;
        default:
            // something wrong
            mystrerror_r(status, errbuff, sizeof errbuff);
            fprintf(stderr,"%s:%d: input error (%s)\n",
                    __FILE__,__LINE__, errbuff);
            exit(EXIT_FAILURE);
        }

        ++snpndx;

        // p and q are frequencies of derived and ancestral alleles
        double p[n], q[n];
        for(j = 0; j < n; ++j) {
            p[j] = ScrmReader_daf(r,j); // derived allele freq
            q[j] = 1.0 - p[j];
        }

        if(logAll) {
            fprintf(logfile, "%5u %10lu\n", ScrmReader_chr(r),
                    ScrmReader_nucpos(r));
        }
        // Contribution of current snp to each site pattern.  Inner
        // loop considers each bit in current pattern.  If that bit is
        // on, multiply z by the derived allele frequency, p. If
        // that bit is off, multiply by q=1-p. In the end, z is Prod
        // p[j]^bit[j] * q[j]^(1-bit[j]) where bit[j] is the value (0
        // or 1) of the j'th bit.
        for(i = 0; i < npat; ++i) {
            tipId_t     pattern = pat[i];
            double      z = 1.0;
            for(j = 0; j < n; ++j) {
                if(pattern & 1u)
                    z *= p[j];
                else
                    z *= q[j];
                pattern >>= 1u;
            }
            if(!isfinite(z)) {
                fprintf(stderr, "%s:%d nonfinite z=%lf\n",
                        __FILE__, __LINE__, z);
                fprintf(stderr, "   pattern=%d\n", pat[i]);
                for(j = 0; j < n; ++j)
                    fprintf(stderr, "   %d: p=%lf q=%lf\n", j, p[j], q[j]);
            }
            assert(0 == (pattern & 1));
            patCount[i] += z;
        }
    }
    printf("# Nucleotide sites: %lu\n", nsites);
    if(nbadaa)
        printf("# Disagreements about alleles: %lu\n", nbadaa);
    if(nfixed)
        printf("# Monomorphic sites: %lu\n", nfixed);
    printf("# Sites used: %lu\n",
           nsites - nbadaa - nfixed);

    // print labels and site patterns
    printf("# %13s %20s\n", "SitePat", "E[count]");
    for(i = 0; i < npat; ++i) {
        printf("%15s %20.7lf\n",
               patLbl(lblsize, lblbuff, pat[i], &lndx), patCount[i]);
    }

    ScrmReader_free(r);
    if(logfile)
        fclose(logfile);
    fprintf(stderr, "scrmpat is finished\n");
    return 0;
}
