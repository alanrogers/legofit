<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Legofit: segment.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Legofit
   </div>
   <div id="projectbrief">infers population history from nucleotide site  patterns.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">segment.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A single segment of a population tree.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;binary.h&quot;</code><br />
<code>#include &quot;branchtab.h&quot;</code><br />
<code>#include &quot;comb.h&quot;</code><br />
<code>#include &quot;error.h&quot;</code><br />
<code>#include &quot;idset.h&quot;</code><br />
<code>#include &quot;idsetset.h&quot;</code><br />
<code>#include &quot;matcoal.h&quot;</code><br />
<code>#include &quot;misc.h&quot;</code><br />
<code>#include &quot;parstore.h&quot;</code><br />
<code>#include &quot;ptrlst.h&quot;</code><br />
<code>#include &quot;ptrptrmap.h&quot;</code><br />
<code>#include &quot;segment.h&quot;</code><br />
<code>#include &quot;setpart.h&quot;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_comb_dat.html">CombDat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_mig_dat.html">MigDat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_set_part_dat.html">SetPartDat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_segment.html">Segment</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a80980b99f59da5df35fe38d61b8b80d0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_id_set_set.html">IdSetSet</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8c.html#a80980b99f59da5df35fe38d61b8b80d0">get_descendants1</a> (int wdim, <a class="el" href="struct_id_set_set.html">IdSetSet</a> **w, int nsamples, tipId_t *<a class="el" href="diffev_8c.html#abae1fd5e985821b8753aa3ba10573f69">sample</a>, int *newdim)</td></tr>
<tr class="memdesc:a80980b99f59da5df35fe38d61b8b80d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a newly-allocated array of <a class="el" href="struct_id_set_set.html" title="The hash table. ">IdSetSet</a> objects.  <a href="#a80980b99f59da5df35fe38d61b8b80d0">More...</a><br /></td></tr>
<tr class="separator:a80980b99f59da5df35fe38d61b8b80d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd10aef33c66699df8f5eaafa844756a"><td class="memItemLeft" align="right" valign="top"><a id="acd10aef33c66699df8f5eaafa844756a"></a>
static <a class="el" href="struct_id_set_set.html">IdSetSet</a> **&#160;</td><td class="memItemRight" valign="bottom"><b>get_descendants2</b> (int dim0, <a class="el" href="struct_id_set_set.html">IdSetSet</a> **w0, int dim1, <a class="el" href="struct_id_set_set.html">IdSetSet</a> **w1, int nsamples, tipId_t *<a class="el" href="diffev_8c.html#abae1fd5e985821b8753aa3ba10573f69">sample</a>, int *newdim)</td></tr>
<tr class="separator:acd10aef33c66699df8f5eaafa844756a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb1bfcc2bd637af82741da72620f03a"><td class="memItemLeft" align="right" valign="top"><a id="a4cb1bfcc2bd637af82741da72620f03a"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>mv_idsets_to_parent</b> (<a class="el" href="struct_segment.html">Segment</a> *self, int ipar, <a class="el" href="struct_ptr_lst.html">PtrLst</a> **a)</td></tr>
<tr class="separator:a4cb1bfcc2bd637af82741da72620f03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ebb7b4bdf9276997571212b8ff1be8"><td class="memItemLeft" align="right" valign="top"><a id="a29ebb7b4bdf9276997571212b8ff1be8"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>coalescent_interval_length</b> (int n, long double elen[n - 1], long double eig[n], long double v)</td></tr>
<tr class="separator:a29ebb7b4bdf9276997571212b8ff1be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ef88aff8edce252dda053ec3a24f5f"><td class="memItemLeft" align="right" valign="top"><a id="a50ef88aff8edce252dda053ec3a24f5f"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>project</b> (int n, long double pr[n], long double eig[n - 1])</td></tr>
<tr class="separator:a50ef88aff8edce252dda053ec3a24f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d012ea9046502a36b49394fe48771a1"><td class="memItemLeft" align="right" valign="top"><a id="a4d012ea9046502a36b49394fe48771a1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8c.html#a4d012ea9046502a36b49394fe48771a1">visitComb</a> (int d, int ndx[d], void *data)</td></tr>
<tr class="memdesc:a4d012ea9046502a36b49394fe48771a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visit a combination. <br /></td></tr>
<tr class="separator:a4d012ea9046502a36b49394fe48771a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addca0a220a6ed66e1e9217ede5e17af7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8c.html#addca0a220a6ed66e1e9217ede5e17af7">visitSetPart</a> (unsigned n, unsigned a[n], void *data)</td></tr>
<tr class="memdesc:addca0a220a6ed66e1e9217ede5e17af7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visit a set partition.  <a href="#addca0a220a6ed66e1e9217ede5e17af7">More...</a><br /></td></tr>
<tr class="separator:addca0a220a6ed66e1e9217ede5e17af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9ff56aaef09533526e0894414c6a90"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8c.html#acc9ff56aaef09533526e0894414c6a90">visitMig</a> (int nmig, int *migndx, void *data)</td></tr>
<tr class="memdesc:acc9ff56aaef09533526e0894414c6a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visit a combination defining migrants.  <a href="#acc9ff56aaef09533526e0894414c6a90">More...</a><br /></td></tr>
<tr class="separator:acc9ff56aaef09533526e0894414c6a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad630fc2db56d4740042c7ad66230b634"><td class="memItemLeft" align="right" valign="top"><a id="ad630fc2db56d4740042c7ad66230b634"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8c.html#ad630fc2db56d4740042c7ad66230b634">unlink_child</a> (<a class="el" href="struct_segment.html">Segment</a> *child, <a class="el" href="struct_segment.html">Segment</a> *parent)</td></tr>
<tr class="memdesc:ad630fc2db56d4740042c7ad66230b634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove child from parent. <br /></td></tr>
<tr class="separator:ad630fc2db56d4740042c7ad66230b634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60851d1309a904ef368e1a4df38b6a0b"><td class="memItemLeft" align="right" valign="top"><a id="a60851d1309a904ef368e1a4df38b6a0b"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>Segment_coalesceFinite</b> (<a class="el" href="struct_segment.html">Segment</a> *self, int dosing, <a class="el" href="struct_branch_tab.html">BranchTab</a> *branchtab, long unsigned *event_counter)</td></tr>
<tr class="separator:a60851d1309a904ef368e1a4df38b6a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab275d027c1c27fd74df619357e86f867"><td class="memItemLeft" align="right" valign="top"><a id="ab275d027c1c27fd74df619357e86f867"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>Segment_coalesceInfinite</b> (<a class="el" href="struct_segment.html">Segment</a> *self, long double v, int dosing, <a class="el" href="struct_branch_tab.html">BranchTab</a> *branchtab)</td></tr>
<tr class="separator:ab275d027c1c27fd74df619357e86f867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78eceee840bd1e05fe9057703225f734"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8c.html#a78eceee840bd1e05fe9057703225f734">Segment_duplicate_nodes</a> (<a class="el" href="struct_segment.html">Segment</a> *old, PtrPtrMap *ppm)</td></tr>
<tr class="memdesc:a78eceee840bd1e05fe9057703225f734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse tree, making a duplicate of each node, and putting the duplicates into a hash map (called ppm) in which the old node is the key and the new duplicate is the value associated with that key.  <a href="#a78eceee840bd1e05fe9057703225f734">More...</a><br /></td></tr>
<tr class="separator:a78eceee840bd1e05fe9057703225f734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75679c03696e5b0937dae47b1500d74a"><td class="memItemLeft" align="right" valign="top"><a id="a75679c03696e5b0937dae47b1500d74a"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>Segment_equals_r</b> (<a class="el" href="struct_segment.html">Segment</a> *a, <a class="el" href="struct_segment.html">Segment</a> *b)</td></tr>
<tr class="separator:a75679c03696e5b0937dae47b1500d74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133993a8de77827db8d214709639eec1"><td class="memItemLeft" align="right" valign="top"><a id="a133993a8de77827db8d214709639eec1"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><b>self_ndx</b> (<a class="el" href="struct_segment.html">Segment</a> *self, <a class="el" href="struct_segment.html">Segment</a> *parent)</td></tr>
<tr class="separator:a133993a8de77827db8d214709639eec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32232a59365d0f286b031a6faf7db3c7"><td class="memItemLeft" align="right" valign="top"><a id="a32232a59365d0f286b031a6faf7db3c7"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8c.html#a32232a59365d0f286b031a6faf7db3c7">w_isempty</a> (int dim, <a class="el" href="struct_id_set_set.html">IdSetSet</a> **w)</td></tr>
<tr class="memdesc:a32232a59365d0f286b031a6faf7db3c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if each <a class="el" href="struct_ptr_lst.html">PtrLst</a> in array w is empty; return 0 otherwise. <br /></td></tr>
<tr class="separator:a32232a59365d0f286b031a6faf7db3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b205e228f0a4a7c699ad9c4786031e5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8c.html#a4b205e228f0a4a7c699ad9c4786031e5">migrate</a> (<a class="el" href="struct_ptr_lst.html">PtrLst</a> *migrants, <a class="el" href="struct_ptr_lst.html">PtrLst</a> *natives, <a class="el" href="struct_ptr_lst.html">PtrLst</a> *sets, int nmig, int *migndx, int nnat, int *natndx, <a class="el" href="struct_mig_dat.html">MigDat</a> *mdat)</td></tr>
<tr class="memdesc:a4b205e228f0a4a7c699ad9c4786031e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">On entry, "sets" is a vector of <a class="el" href="struct_id_set.html">IdSet</a> objects, which will be copied, and the copies allocated among migrants and natives.  <a href="#a4b205e228f0a4a7c699ad9c4786031e5">More...</a><br /></td></tr>
<tr class="separator:a4b205e228f0a4a7c699ad9c4786031e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2768120aae871e85c91eaf797c5482a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8c.html#ad2768120aae871e85c91eaf797c5482a">mv_to_waiting_room</a> (<a class="el" href="struct_segment.html">Segment</a> *self, <a class="el" href="struct_ptr_lst.html">PtrLst</a> *src, int ipar, int nlin)</td></tr>
<tr class="memdesc:ad2768120aae871e85c91eaf797c5482a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move <a class="el" href="struct_id_set.html">IdSet</a> objects from list "src" into the relevant waiting room of parent ipar.  <a href="#ad2768120aae871e85c91eaf797c5482a">More...</a><br /></td></tr>
<tr class="separator:ad2768120aae871e85c91eaf797c5482a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7505227cbeacdf56fa999380ada6df2"><td class="memItemLeft" align="right" valign="top"><a id="ae7505227cbeacdf56fa999380ada6df2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Segment_print_d</b> (<a class="el" href="struct_segment.html">Segment</a> *self, const char *func, int line)</td></tr>
<tr class="separator:ae7505227cbeacdf56fa999380ada6df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb67229716df316e6c7e5cb8947f1f1"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8c.html#a8cb67229716df316e6c7e5cb8947f1f1">tipidcmp</a> (const void *vx, const void *vy)</td></tr>
<tr class="memdesc:a8cb67229716df316e6c7e5cb8947f1f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This sorts tipId_t values into numerical order, unlike the more complex comparison function, compare_tipId, which is defined in <a class="el" href="lblndx_8c.html" title="An index of sample labels. ">lblndx.c</a>.  <a href="#a8cb67229716df316e6c7e5cb8947f1f1">More...</a><br /></td></tr>
<tr class="separator:a8cb67229716df316e6c7e5cb8947f1f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40aad6f05f363a49d1551ada7220ce29"><td class="memItemLeft" align="right" valign="top"><a id="a40aad6f05f363a49d1551ada7220ce29"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>Segment_print_r</b> (<a class="el" href="struct_segment.html">Segment</a> *self, FILE *fp, int indent)</td></tr>
<tr class="separator:a40aad6f05f363a49d1551ada7220ce29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8cb2c52e50be2c4483a86a301850fa0"><td class="memItemLeft" align="right" valign="top"><a id="af8cb2c52e50be2c4483a86a301850fa0"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>Segment_new</b> (int twoN_i, int start_i, <a class="el" href="struct_par_store.html">ParStore</a> *ps, const char *label)</td></tr>
<tr class="separator:af8cb2c52e50be2c4483a86a301850fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad82bb974b2773269d2ec084cf4ee8bab"><td class="memItemLeft" align="right" valign="top"><a id="ad82bb974b2773269d2ec084cf4ee8bab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Segment_free</b> (<a class="el" href="struct_segment.html">Segment</a> *self)</td></tr>
<tr class="separator:ad82bb974b2773269d2ec084cf4ee8bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9afa142d02ff5cf69a9595997e9fe919"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8c.html#a9afa142d02ff5cf69a9595997e9fe919">Segment_prune</a> (<a class="el" href="struct_segment.html">Segment</a> *self)</td></tr>
<tr class="memdesc:a9afa142d02ff5cf69a9595997e9fe919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse network, removing segments with no children and no samples.  <a href="#a9afa142d02ff5cf69a9595997e9fe919">More...</a><br /></td></tr>
<tr class="separator:a9afa142d02ff5cf69a9595997e9fe919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1fba94b1d49e468e3b43016c3e76bba"><td class="memItemLeft" align="right" valign="top"><a id="ab1fba94b1d49e468e3b43016c3e76bba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Segment_update</b> (<a class="el" href="struct_segment.html">Segment</a> *self, <a class="el" href="struct_par_store.html">ParStore</a> *ps)</td></tr>
<tr class="separator:ab1fba94b1d49e468e3b43016c3e76bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ad3b8d2f3503a63b9b75d51d0c4b73"><td class="memItemLeft" align="right" valign="top"><a id="ad4ad3b8d2f3503a63b9b75d51d0c4b73"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8c.html#ad4ad3b8d2f3503a63b9b75d51d0c4b73">Segment_unvisit</a> (<a class="el" href="struct_segment.html">Segment</a> *self)</td></tr>
<tr class="memdesc:ad4ad3b8d2f3503a63b9b75d51d0c4b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all "visited" flags to false. <br /></td></tr>
<tr class="separator:ad4ad3b8d2f3503a63b9b75d51d0c4b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1d782daf677f39b1a19e638f21dd21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8c.html#a5f1d782daf677f39b1a19e638f21dd21">Segment_newSample</a> (<a class="el" href="struct_segment.html">Segment</a> *self, unsigned ndx)</td></tr>
<tr class="memdesc:a5f1d782daf677f39b1a19e638f21dd21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new sample to a <a class="el" href="struct_segment.html">Segment</a>.  <a href="#a5f1d782daf677f39b1a19e638f21dd21">More...</a><br /></td></tr>
<tr class="separator:a5f1d782daf677f39b1a19e638f21dd21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d2730d17e534deb0d722b17fd17662"><td class="memItemLeft" align="right" valign="top"><a id="a85d2730d17e534deb0d722b17fd17662"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Segment_addChild</b> (void *vparent, void *vchild)</td></tr>
<tr class="separator:a85d2730d17e534deb0d722b17fd17662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e350a85ba0945c826ab2a66ce25777"><td class="memItemLeft" align="right" valign="top"><a id="a33e350a85ba0945c826ab2a66ce25777"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8c.html#a33e350a85ba0945c826ab2a66ce25777">Segment_sanityCheck</a> (<a class="el" href="struct_segment.html">Segment</a> *self, const char *file, int lineno)</td></tr>
<tr class="memdesc:a33e350a85ba0945c826ab2a66ce25777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check sanity of <a class="el" href="struct_segment.html">Segment</a>. <br /></td></tr>
<tr class="separator:a33e350a85ba0945c826ab2a66ce25777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad478e16a02dcf347e5b6b3644219889f"><td class="memItemLeft" align="right" valign="top"><a id="ad478e16a02dcf347e5b6b3644219889f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Segment_mix</b> (void *vchild, int mix_i, void *vintrogressor, void *vnative, <a class="el" href="struct_par_store.html">ParStore</a> *ps)</td></tr>
<tr class="separator:ad478e16a02dcf347e5b6b3644219889f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a086bb6d1631c6a08f97bc21f8e61d8"><td class="memItemLeft" align="right" valign="top"><a id="a3a086bb6d1631c6a08f97bc21f8e61d8"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8c.html#a3a086bb6d1631c6a08f97bc21f8e61d8">Segment_root</a> (void *vself)</td></tr>
<tr class="memdesc:a3a086bb6d1631c6a08f97bc21f8e61d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find root of population network, starting from given node. <br /></td></tr>
<tr class="separator:a3a086bb6d1631c6a08f97bc21f8e61d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099fb773ae43b71e0661e0d12a9c3372"><td class="memItemLeft" align="right" valign="top"><a id="a099fb773ae43b71e0661e0d12a9c3372"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8c.html#a099fb773ae43b71e0661e0d12a9c3372">Segment_feasible</a> (const <a class="el" href="struct_segment.html">Segment</a> *self, <a class="el" href="struct_bounds.html">Bounds</a> bnd, int verbose)</td></tr>
<tr class="memdesc:a099fb773ae43b71e0661e0d12a9c3372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if parameters satisfy inequality constraints, or 0 otherwise. <br /></td></tr>
<tr class="separator:a099fb773ae43b71e0661e0d12a9c3372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2148771de959defaf907b584ca48f02b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_segment.html">Segment</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8c.html#a2148771de959defaf907b584ca48f02b">Segment_dup</a> (<a class="el" href="struct_segment.html">Segment</a> *old_root, PtrPtrMap *ppm)</td></tr>
<tr class="memdesc:a2148771de959defaf907b584ca48f02b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate a network of nodes, returning a pointer to the root of the duplicate network.  <a href="#a2148771de959defaf907b584ca48f02b">More...</a><br /></td></tr>
<tr class="separator:a2148771de959defaf907b584ca48f02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40a07b6dd45a500b63a06a9d2b05a90"><td class="memItemLeft" align="right" valign="top"><a id="ac40a07b6dd45a500b63a06a9d2b05a90"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Segment_print</b> (void *vroot, FILE *fp, int indent)</td></tr>
<tr class="separator:ac40a07b6dd45a500b63a06a9d2b05a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9106edb3d61b343dd53b8cec9e61ae8"><td class="memItemLeft" align="right" valign="top"><a id="ab9106edb3d61b343dd53b8cec9e61ae8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Segment_equals</b> (<a class="el" href="struct_segment.html">Segment</a> *a, <a class="el" href="struct_segment.html">Segment</a> *b)</td></tr>
<tr class="separator:ab9106edb3d61b343dd53b8cec9e61ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e2c21823ca23d0329eb0ad86d421e6"><td class="memItemLeft" align="right" valign="top"><a id="a54e2c21823ca23d0329eb0ad86d421e6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Segment_coalesce</b> (<a class="el" href="struct_segment.html">Segment</a> *self, int dosing, <a class="el" href="struct_branch_tab.html">BranchTab</a> *branchtab, long unsigned *event_counter)</td></tr>
<tr class="separator:a54e2c21823ca23d0329eb0ad86d421e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b5186546d9de0eb8b8eeed31e7f84d2"><td class="memItemLeft" align="right" valign="top"><a id="a0b5186546d9de0eb8b8eeed31e7f84d2"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>coalescent_interval_length</b> (int n, long double elen[n], long double eig[n - 1], long double v)</td></tr>
<tr class="separator:a0b5186546d9de0eb8b8eeed31e7f84d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e6fc738df1128f12588992eee409df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8c.html#aa2e6fc738df1128f12588992eee409df">Segment_clear</a> (<a class="el" href="struct_segment.html">Segment</a> *self)</td></tr>
<tr class="memdesc:aa2e6fc738df1128f12588992eee409df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all references to samples from tree of populations.  <a href="#aa2e6fc738df1128f12588992eee409df">More...</a><br /></td></tr>
<tr class="separator:aa2e6fc738df1128f12588992eee409df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266ed04486d49d1d443d9b991e9761f2"><td class="memItemLeft" align="right" valign="top"><a id="a266ed04486d49d1d443d9b991e9761f2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="segment_8c.html#a266ed04486d49d1d443d9b991e9761f2">Segment_isClear</a> (const <a class="el" href="struct_segment.html">Segment</a> *self)</td></tr>
<tr class="memdesc:a266ed04486d49d1d443d9b991e9761f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if <a class="el" href="struct_segment.html">Segment</a> tree is empty of samples. <br /></td></tr>
<tr class="separator:a266ed04486d49d1d443d9b991e9761f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a29dc007556112a006bfe3e7bf362146a"><td class="memItemLeft" align="right" valign="top"><a id="a29dc007556112a006bfe3e7bf362146a"></a>
tipId_t&#160;</td><td class="memItemRight" valign="bottom"><b>union_all_samples</b></td></tr>
<tr class="separator:a29dc007556112a006bfe3e7bf362146a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f98b46f90c7ef85bce6cd2f6b773fa4"><td class="memItemLeft" align="right" valign="top"><a id="a0f98b46f90c7ef85bce6cd2f6b773fa4"></a>
long double&#160;</td><td class="memItemRight" valign="bottom"><b>improbable</b></td></tr>
<tr class="separator:a0f98b46f90c7ef85bce6cd2f6b773fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A single segment of a population tree. </p>
<dl class="section author"><dt>Author</dt><dd>Alan R. Rogers </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright (c) 2020, Alan R. Rogers <a href="#" onclick="location.href='mai'+'lto:'+'rog'+'er'+'s@a'+'nt'+'hro'+'.u'+'tah'+'.e'+'du'; return false;">roger<span style="display: none;">.nosp@m.</span>s@an<span style="display: none;">.nosp@m.</span>thro.<span style="display: none;">.nosp@m.</span>utah<span style="display: none;">.nosp@m.</span>.edu</a>. This file is released under the Internet Systems Consortium License, which can be found in file "LICENSE". </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a80980b99f59da5df35fe38d61b8b80d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80980b99f59da5df35fe38d61b8b80d0">&#9670;&nbsp;</a></span>get_descendants1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_id_set_set.html">IdSetSet</a> ** get_descendants1 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>wdim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_id_set_set.html">IdSetSet</a> **&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nsamples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">tipId_t *&#160;</td>
          <td class="paramname"><em>sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>newdim</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a newly-allocated array of <a class="el" href="struct_id_set_set.html" title="The hash table. ">IdSetSet</a> objects. </p>
<p>The i'th object contains all the <a class="el" href="struct_id_set.html">IdSet</a> entries in w[i], with each entry augmented by the entries (if any) in vector "sample". If there are no entries in any of the w[i], the returned array contains a single non-empty entry, with the entries of "samples". If "w" and "samples" are both empty, *newdim will equal 0 and the function returns NULL. Otherwise, *newdim is the dimension of the returned array.</p>
<p>On entry, wdim is the dimension of array w, and nsamples is the dimension of array sample. On return *newdim is the dimension of the newly-allocated array returned by the function. </p>

</div>
</div>
<a id="a4b205e228f0a4a7c699ad9c4786031e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b205e228f0a4a7c699ad9c4786031e5">&#9670;&nbsp;</a></span>migrate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void migrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_ptr_lst.html">PtrLst</a> *&#160;</td>
          <td class="paramname"><em>migrants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ptr_lst.html">PtrLst</a> *&#160;</td>
          <td class="paramname"><em>natives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ptr_lst.html">PtrLst</a> *&#160;</td>
          <td class="paramname"><em>sets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nmig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>migndx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nnat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>natndx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_mig_dat.html">MigDat</a> *&#160;</td>
          <td class="paramname"><em>mdat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>On entry, "sets" is a vector of <a class="el" href="struct_id_set.html">IdSet</a> objects, which will be copied, and the copies allocated among migrants and natives. </p>
<p>Each copy will acquire a MigOutcome label, which is constructed using mig_event, mig_outcome, and mig_pr. Each set within "sets" should have the same length (number of tipId_t values), and that length should correspond to the indices in arrays "migndx" and "natndx". The first of these arrays holds the indices of the migrant tipId_t values within each set, and the second holds indices of natives. On return, "migrants" and "natives" contain <a class="el" href="struct_id_set.html">IdSet</a> objects of migrants and natives. </p>

</div>
</div>
<a id="ad2768120aae871e85c91eaf797c5482a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2768120aae871e85c91eaf797c5482a">&#9670;&nbsp;</a></span>mv_to_waiting_room()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void mv_to_waiting_room </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_segment.html">Segment</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_ptr_lst.html">PtrLst</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ipar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nlin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move <a class="el" href="struct_id_set.html">IdSet</a> objects from list "src" into the relevant waiting room of parent ipar. </p>
<p>"nlin" is the number of lineages in each <a class="el" href="struct_id_set.html">IdSet</a> object within "src". It also serves as the index into the parental waiting room. On return, "src" is empty, and self-&gt;parent[ipar]-&gt;w[iself][nlin] contains the <a class="el" href="struct_id_set.html">IdSet</a> objects that were originally in "src". Here, "iself" is the index of "self" in the parent's list of children. </p>

</div>
</div>
<a id="aa2e6fc738df1128f12588992eee409df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e6fc738df1128f12588992eee409df">&#9670;&nbsp;</a></span>Segment_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Segment_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_segment.html">Segment</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all references to samples from tree of populations. </p>
<p>Sets "visited" to 0 in every node. </p>

</div>
</div>
<a id="a2148771de959defaf907b584ca48f02b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2148771de959defaf907b584ca48f02b">&#9670;&nbsp;</a></span>Segment_dup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_segment.html">Segment</a>* Segment_dup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_segment.html">Segment</a> *&#160;</td>
          <td class="paramname"><em>old_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PtrPtrMap *&#160;</td>
          <td class="paramname"><em>ppm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Duplicate a network of nodes, returning a pointer to the root of the duplicate network. </p>
<p>On entry, ppm should be an empty hashmap. </p>

<p class="reference">References <a class="el" href="segment_8c.html#a78eceee840bd1e05fe9057703225f734">Segment_duplicate_nodes()</a>, and <a class="el" href="segment_8c.html#ad4ad3b8d2f3503a63b9b75d51d0c4b73">Segment_unvisit()</a>.</p>

</div>
</div>
<a id="a78eceee840bd1e05fe9057703225f734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78eceee840bd1e05fe9057703225f734">&#9670;&nbsp;</a></span>Segment_duplicate_nodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Segment_duplicate_nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_segment.html">Segment</a> *&#160;</td>
          <td class="paramname"><em>old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PtrPtrMap *&#160;</td>
          <td class="paramname"><em>ppm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Traverse tree, making a duplicate of each node, and putting the duplicates into a hash map (called ppm) in which the old node is the key and the new duplicate is the value associated with that key. </p>

<p class="reference">References <a class="el" href="misc_8c.html#a0289f2f0a4cc23bb8741b455e40e9920">memdup()</a>.</p>

<p class="reference">Referenced by <a class="el" href="segment_8c.html#a2148771de959defaf907b584ca48f02b">Segment_dup()</a>.</p>

</div>
</div>
<a id="a5f1d782daf677f39b1a19e638f21dd21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f1d782daf677f39b1a19e638f21dd21">&#9670;&nbsp;</a></span>Segment_newSample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Segment_newSample </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_segment.html">Segment</a> *&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ndx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new sample to a <a class="el" href="struct_segment.html">Segment</a>. </p>
<p>This is called once for each of the samples specified in the .lgo file. </p>

</div>
</div>
<a id="a9afa142d02ff5cf69a9595997e9fe919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9afa142d02ff5cf69a9595997e9fe919">&#9670;&nbsp;</a></span>Segment_prune()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Segment_prune </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_segment.html">Segment</a> *&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverse network, removing segments with no children and no samples. </p>
<p>These do not contribute to the calculation. </p>

<p class="reference">References <a class="el" href="segment_8c.html#ad630fc2db56d4740042c7ad66230b634">unlink_child()</a>.</p>

</div>
</div>
<a id="a8cb67229716df316e6c7e5cb8947f1f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cb67229716df316e6c7e5cb8947f1f1">&#9670;&nbsp;</a></span>tipidcmp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int tipidcmp </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>vy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This sorts tipId_t values into numerical order, unlike the more complex comparison function, compare_tipId, which is defined in <a class="el" href="lblndx_8c.html" title="An index of sample labels. ">lblndx.c</a>. </p>

</div>
</div>
<a id="acc9ff56aaef09533526e0894414c6a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc9ff56aaef09533526e0894414c6a90">&#9670;&nbsp;</a></span>visitMig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int visitMig </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nmig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>migndx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Visit a combination defining migrants. </p>
<p>migndx has the 0-based indices of the current set of migrants. Its length is nmig, which may be zero. </p>

</div>
</div>
<a id="addca0a220a6ed66e1e9217ede5e17af7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addca0a220a6ed66e1e9217ede5e17af7">&#9670;&nbsp;</a></span>visitSetPart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int visitSetPart </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>a</em>[n], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Visit a set partition. </p>
<p>n is the number of descendants, a[i] is the index of the ancestor of the i'th descendant. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 1 2021 08:59:54 for Legofit by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
