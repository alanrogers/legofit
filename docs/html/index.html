<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Legofit: Legofit</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Legofit
   </div>
   <div id="projectbrief">infers population history from nucleotide site</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Legofit </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md21"></a>
Introduction</h1>
<p >Legofit is a computer package that uses counts of nucleotide site patterns to estimate the history of population size, subdivision, and gene flow. The package consists of the following programs</p>
<ul>
<li><a class="el" href="axt2raf.html">axt2raf</a> reads an axt file and writes a file in raf format.</li>
<li><a class="el" href="bepe.html">bepe</a> calculates the "bootstrap estimate of prediction
  error" (Efron and Tibshirani, 1993).</li>
<li><a class="el" href="booma.html">booma</a> does bootstrap model averaging (Buckland et al. Biometrics, 53(2):603-618).</li>
<li><a class="el" href="clic.html">clic</a> calculates the "composite likelihood information
  criterion" (Varin and Vidoni, 2005).</li>
<li><a class="el" href="bootci.html">bootci.py</a> reads a flat file to generate bootstrap confidence intervals.</li>
<li><a class="el" href="index.html#daf">daf</a> writes genetic data into the ".daf" format, which is used by <a class="el" href="tabpat.html">tabpat</a>.</li>
<li><a class="el" href="diverg.html">diverg.py</a> compares two distributions of site pattern frequencies, using the Kullback-Leibler (KL) divergence.</li>
<li><a class="el" href="flatfile.html">flatfile.py</a> reads a list of legofit output files and writes a flat file with a row for each legofit file and a column for each parameter.</li>
<li><a class="el" href="flatpat.html">flatpat.py</a> reads a list of files containing site pattern frequencies. These may include the output of tabulation programs such as sitepat, scrmpat, and simpat, or the output of legofit or legosim. Writes a flat file with a column for each site pattern and a row for each input file.</li>
<li><a class="el" href="joinraf.html">joinraf</a> joins several raf files line by line to make a new raf file.</li>
<li><a class="el" href="legofit.html">legofit</a> estimates parameters from site pattern counts.</li>
<li><a class="el" href="legosim.html">legosim</a> predicts site pattern counts from assumptions about population history.</li>
<li>legotree.py makes a graph from a .lgo file.</li>
<li><a class="el" href="ms2sim.html">ms2sim</a> reads the output of the ms coalescent simulator and rewrites it in "sim" format, which can be piped to <a class="el" href="simpat.html">simpat</a> to tabulate site pattern frequencies.</li>
<li><a class="el" href="pclgo.html">pclgo</a> reads legofit output files produced from simulation or bootstrap replicates and re-expresses free variables in terms of principal components.</li>
<li><a class="el" href="index.html#raf">raf</a> writes genetic data into the ".raf" format, which is used by <a class="el" href="sitepat.html">sitepat</a>.</li>
<li><a class="el" href="rafdaf.html">rafdaf</a> reads several ".raf" files and writes derived allele frequencies for each position in the genome.</li>
<li><a class="el" href="resid.html">resid</a> prints site pattern frequencies or residuals, optionally deleting some population labels and/or mapping multiple population labels into single labels.</li>
<li><a class="el" href="scrmpat.html">scrmpat</a> tabulates site patterns from output generated by the <a href="https://scrm.github.io">scrm</a> coalescent simulator.</li>
<li><a class="el" href="simpat.html">simpat</a> tabulates site patterns from the output of <code>ms2sim</code> or <a href="https://github.com/tskit-dev/msprime">msprime</a>.</li>
<li><a class="el" href="sitepat.html">sitepat</a> reads ".raf" files for several populations, tabulates "nucleotide site patterns" (explained below), and generates moving-blocks bootstrap replicates.</li>
<li><a class="el" href="tabpat.html">tabpat</a> reads ".daf" files for several populations, tabulates "nucleotide site patterns" (explained below), and generates moving-blocks bootstrap replicates.</li>
</ul>
<h1><a class="anchor" id="sitepattern"></a>
Nucleotide site patterns</h1>
<p >These programs all operate on "nucleotide site patterns", which are summary statistics not influenced by recent population size but rich in information about ancestral populations. This section will define site patterns and explain how legofit tabulates their counts, and estimates expectations.</p>
<p >Consider a sample consisting of one haploid genome drawn from each of 3 populations, <em>X</em>, <em>Y</em>, and <em>Z</em>. Suppose that, at a given nucleotide site, the derived allele is present in the genomes from <em>X</em> and <em>Y</em> but not that from <em>Z</em>. If so, then this nucleotide position will be said to exhibit the "*xy* site pattern." We ignore cases in which the derived allele is present in none of the samples or in all of them. By default (without the <code>-1</code> argument of <a class="el" href="legosim.html">legosim</a> and <a class="el" href="legofit.html">legofit</a>), we also ignore "singleton site patterns"&mdash;those in which the derived allele appears only once. In other words, we consider only polymorphic, non-singleton site patterns. For the special case of the 3-population sample just described, there are only 3 such site patterns: <em>xy</em>, <em>xz</em>, and <em>yz</em>.</p>
<p >In the general case, with samples from <em>K</em> populations, the number of site patterns (including singletons) is <img class="formulaInl" alt="$2^K - 2$" src="form_9.png"/>. For example, there are 14 site patterns in a sample involving <img class="formulaInl" alt="$K=4$" src="form_10.png"/> populations. The table below shows data from a sample involving 4 populations, <em>X</em>, <em>Y</em>, <em>N</em>, and <em>D</em>. </p><pre class="fragment">SitePat     E[count]
      x   528808.000
      y   518558.875
      n   529267.375
      d   581255.250
    x:y   320273.625
    x:n    43345.375
    x:d    41517.750
    y:n    49486.000
    y:d    40366.375
    n:d   255980.625
  x:y:n   108149.000
  x:y:d    91739.375
  x:n:d    89563.375
  y:n:d    91388.250
</pre><p> The <code>E[count]</code> column shows numbers that can be thought of loosely as counts of site patterns in a genome-wide sample.</p>
<p >These number cannot really be counts, because they aren't integers. This reflects the fact that our sample includes more than one haploid genome from each population, and a given SNP may contribute to several site patterns. The contribution to a given site pattern is the probability that a sub-sample, consisting of one haploid genome drawn at random from the larger sample of each population, would exhibit this site pattern. For example, suppose we have samples from three populations, <em>X</em>, <em>Y</em>, and <em>N</em>, and let <img class="formulaInl" alt="$p_{iX}$" src="form_11.png"/>, <img class="formulaInl" alt="$p_{iY}$" src="form_12.png"/>, and <img class="formulaInl" alt="$p_{iN}$" src="form_13.png"/> represent the frequencies of the derived allele at SNP <em>i</em> in these three samples. Then site pattern <em>xy</em> occurs at SNP <em>i</em> with probability <img class="formulaInl" alt="$z_i =
p_{iX}p_{iY}(1-p_{iN})$" src="form_14.png"/> (Patterson et al 2010, Science, 328(5979):S129). Aggregating over SNPs, <img class="formulaInl" alt="$I_{xy} = \sum_i z_i$" src="form_15.png"/> summarizes the information in the data about this site pattern. These are the numbers that appear in the 2nd column of the table above.</p>
<p >Tables such as the one above are generated by programs <a class="el" href="tabpat.html">tabpat</a>, <a class="el" href="sitepat.html">sitepat</a>, <a class="el" href="scrmpat.html">scrmpat</a>, and <a class="el" href="simpat.html">simpat</a>.</p>
<h1><a class="anchor" id="installation"></a>
Installation and testing</h1>
<p >The package is available at <a href="https://github.com/alanrogers/legofit" title="GitHub">github</a>. Before compiling, you must install two libraries: <code>pthreads</code> and <a href="http://www.gnu.org/software/gsl">gsl</a>. You will need not only the libraries themselves but also several header files, such as <code>pthread.h</code>. I didn't need to install <code>pthreads</code>, because it came bundled with the Gnu C compiler. But the gsl was an extra. Under ubuntu Linux, you can install it like this: </p><pre class="fragment">sudo apt-get install libgsl0-dev
</pre><p> On the mac, using homebrew, the command is </p><pre class="fragment">brew install gsl
</pre><p> By default, the executable files will be copied into a directory named <code>bin</code> in your home directory. If you want them to go somewhere else, edit the first non-comment line of src/Makefile.</p>
<p >Then</p>
<ol type="1">
<li>cd into the src directory.</li>
<li>Type "make".</li>
<li>Type "make install".</li>
</ol>
<p >This will try to place the executables into directory "bin" in the user's home directory. Make sure this directory appears in your PATH, so that the shell can find it.</p>
<p >There is also a facility for installing a "global" version of the code for other users. The first step (under unix-like operating systems) is to set up a "soft link" to the directory just above the target bin directory. Then type "sudo make ginstall". You'll need administrative privileges. For example, to install the software in <code>/usr/local/bin</code>: </p><pre class="fragment">cd                     # move into home directory
ln -s /usr/local group # now "group" points to `/usr/local`
</pre><p> Then <code>cd</code> back into the <code>legofit</code> directory and type </p><pre class="fragment">sudo make ginstall     # install into /usr/local/bin
</pre><p> This installation will work under unix-like operating systems, such as linux and Apple's osx. I'm told that it also compiles under Windows. If you use Windows, I suggest running Legofit under the Windows Linux Subsystem.</p>
<p >The directory <code>test</code> contains a unit test for many of the .c files in directory <code>src</code>. Within this directory, type</p>
<ol type="1">
<li>make xboot</li>
<li>./xboot</li>
</ol>
<p >to test the source file <code><a class="el" href="boot_8c.html" title="Functions for a moving blocks bootstrap.">boot.c</a></code>. To run all unit tests, type "make". This will take awhile, as some of the unit tests are slow.</p>
<h1><a class="anchor" id="sortorder"></a>
Sort order</h1>
<p >Several programs&ndash;<code>bepe</code>, <code>clic</code>, and <code><a class="el" href="flatfile_8py.html">flatfile.py</a></code>&ndash;take lists of files on the command line. These lists are most easily generated using wildcard expansions, such as </p><pre class="fragment">flatfile.py foo*.legofit
</pre><p> Here "foo*.legofit" will expand into a list of file names from the current directory. It is important that these lists be in a consistent order, so that <code>booma</code> can integrate multiple files created by <code>bepe</code>, <code>clic</code>, and <code><a class="el" href="flatfile_8py.html">flatfile.py</a></code>.</p>
<p >Unfortunately, the order of files in a wild-card expansion depends on the locale settings of the local machine. If these differ, files generated on one machine will not be compatible with those generated on another. <code>booma</code> can check the consistency of files generated with <code>bepe</code> and <code>clic</code>, but no automatic check is possible with files generated by <code><a class="el" href="flatfile_8py.html">flatfile.py</a></code>.</p>
<p >If you are using the bash shell, which is now available on Windows as well as Linux and macOS, you can ensure a consistent order by executing the following command: </p><pre class="fragment">export LC_ALL=C
</pre><p> Do this before executing <code>bepe</code>, <code>clic</code>, or <code><a class="el" href="flatfile_8py.html">flatfile.py</a></code>. Or put the command into the <code>.profile</code> file (or equivalent) in your home directory.</p>
<p >Under the C shell (<code>csh</code> or <code>tcsh</code>), the command would be: </p><pre class="fragment">setenv LC_ALL C
</pre> <h1><a class="anchor" id="autotoc_md22"></a>
Genetic input data</h1>
<p >Before doing data analysis with <code>legofit</code>, you must generate data files in one of two formats: "daf" (for derived allele frequency), or "raf" (for reference allele frequency). The first of these alternatives requires input data in which the ancestral allele has been previously called. The second ("raf") does not. Instead, the program <a class="el" href="sitepat.html">sitepat</a> uses an outgroup sequence to call ancestral alleles on the fly.</p>
<h2><a class="anchor" id="daf"></a>
daf format</h2>
<p >This was the only input data format in early versions of the legofit package. We began moving away from it when we realized that, under certain circumstances, it can introduce bias. To understand why, suppose we have data from 4 populations, A, B, C, and D. Suppose further that D has received gene flow from an unobserved population, which is distantly related to the 4 observed populations. This gene flow will introduce derived alleles into D, but at these sites A, B, and C will be fixed for the ancestral allele. If ancestral allele calls are based only on A, B, and C, then no ancestral allele calls will be available for sites at which derived alleles have been introduced into D. The gene flow into D will therefore be undetectable. To avoid such problems, it is best to call ancestral alleles during the process of tabulating site patterns, using the programs <a class="el" href="index.html#raf">raf</a> and <a class="el" href="sitepat.html">sitepat</a>. Nonetheless, we retain <a class="el" href="index.html#daf">daf</a> and <a class="el" href="tabpat.html">tabpat</a> for backwards compatibility.</p>
<p >The suffix "daf" stands for "derived allele frequency". See the <a class="el" href="index.html#daf">daf</a> command for instructions on translating from "vcf" or "bcf" format into "daf".</p>
<p >The "daf" file is simple and looks like this: </p><pre class="fragment">#chr        pos aa da                  daf
   1     752566  g  a 0.835294117647058854
   1     754192  a  g 0.858823529411764652
   1     755225  t  g 0.000000000000000000
   1     755228  t  g 0.000000000000000000
   1     765437  g  a 0.000000000000000000
</pre><p> Columns are separated by one or more whitespace characters (tabs and spaces). The first line (beginning with "#") is an optional comment, which is used here to label the columns. The columns are as follows:</p>
<ol type="1">
<li>Character strings that label chromosomes or scaffolds.</li>
<li>Position of the SNP on the chromosome or scaffold, measured in base pairs. Daf format doesn't care whether nucleotide positions are numbered beginning with 0 or with 1, provided that they are consistent across files in a given analysis.</li>
<li>Ancestral allele.</li>
<li>Derived allele. Indels and loci with 3 or more alleles should be excluded.</li>
<li>Frequency of the derived allele within the sample.</li>
</ol>
<p >The lines should be sorted lexically by chromosome. Within chromosomes, they should be sorted in ascending numerical order of column 2. There should be no duplicate (chromosome, position) pairs.</p>
<h2><a class="anchor" id="raf"></a>
raf format</h2>
<p >The suffix "raf" stands for "reference allele frequency". See the <a class="el" href="index.html#raf">raf</a> command for instructions on translating from "vcf" or "bcf" format into "raf". See <a class="el" href="axt2raf.html">axt2raf</a> for translating from "axt" format into "raf".</p>
<p >The "raf" file is simple and looks like this: </p><pre class="fragment">#chr  pos    ref  alt raf
1     752566 g    .   0.835294117647058854
1     754192 a    g   0.858823529411764652
1     755225 t    a   0.000000000000000000
1     755228 t    .   0.000000000000000000
1     765437 g    .   0.000000000000000000
</pre><p> Columns are separated by single tab characters. The first line (beginning with "#") is an optional comment, which is used here to label the columns. Lines whose first non-white character is "#" are interpreted as comments and are ignored during input. They can occur anywhere in the .raf file.</p>
<p >The columns of a .raf file are as follows:</p>
<ol type="1">
<li>Character strings that label chromosomes or scaffolds.</li>
<li>Position of the site on the chromosome or scaffold, measured in base pairs. Raf format doesn't care whether nucleotide positions are numbered beginning with 0 or with 1, provided that they are consistent across files in a given analysis.</li>
<li>Reference allele.</li>
<li>Alternate allele. Indels and loci with 3 or more alleles should be excluded.</li>
<li>Frequency of the reference allele within the sample.</li>
</ol>
<p >The lines should be sorted lexically by chromosome. Within chromosomes, they should be sorted in ascending numerical order of column 2. There should be no duplicate (chromosome, position) pairs.</p>
<p >Raf files can be concatenated easily, by standard tools such as the linux command <code>cat</code>.</p>
<h1><a class="anchor" id="lgo"></a>
Describing population history in an lgo file</h1>
<p >The ".lgo" format describes the history of population size, subdivision, and gene flow. It also identifies the position within the population network of each genetic sample. It is a plain-text file, which should be constructed with a text editor.</p>
<p >In the paragraphs below, I will introduce a small .lgo file a few lines at a time. The first line in my file is </p><pre class="fragment"># Example .lgo file
</pre><p> This is a comment. Comments extend from the sharp character to the end of the line. The next two lines define two convenience variables, whose names are "zero" and "one" </p><pre class="fragment">time fixed    zero=0
twoN fixed     one=1
</pre><p> The first is a "time" variable, which I will use for the tips of branches, where time equals 0. I declare it "fixed", which means that it will not change. Variable names must begin with a letter. Subsequent characters may be letters, digits, or underscores. The second variable declaration begins with "twoN", which indicates that this variable refers to haploid population size&ndash;twice twice the size of the diploid population. When there is only one sample per population, the sizes of tip populations don't matter, so I set them all equal to "one". Next, three more time variables named "Txyn", "Tn", and "Txy". </p><pre class="fragment">time fixed    Tn=1897          # time of Neanderthal admixture
time free     Txyn=25920       # archaic-modern separation time
time free     Txy=3788         # Africa-Eurasia separation time
</pre><p> The comments hint at the meanings of these variables; the values are in generations. The first of these variables is "fixed" (see above). The other two are "free", which means that <code>legofit</code> will estimate their values. Numerical values may optionally be written in exponential notation. For example the last line above could have been written as </p><pre class="fragment">time free     Txy=3.788e3      # Africa-Eurasia separation time
</pre><p> Our measure of population size is twice the effective size of the population, and we define two such variables: </p><pre class="fragment">twoN free         twoNn=1e3            # archaic population size
twoN constrained twoNxy=1e4 - 1.2*Txy  # early modern population size
</pre><p> The first of these is a free parameter, but the second is a new category: "constrained". It defines "twoNxy" as a function of "Txy". Constraints are useful when analysis of bootstrap samples indicates a tight relationship between two or more free parameters. Constraints reduce the number of free parameters and allow more accurate estimates. In the constraint above, there are only two terms and one independent variable&mdash;"Txy". It is legal, however, to use any number of terms and independent variables. For example, we could have written </p><pre class="fragment">twoN constrained twoNxy=1e4 - 1.2*Txy + 0.01*Txy*Txyn # OK
</pre><p> It is safest to put spaces around plus and minus signs. For example, the following would fail: </p><pre class="fragment">twoN constrained twoNxy=1e4 -1.2*Txy  # Fails
</pre><p> The parser interprets "-1.2" as a number, not as an operator (-) followed by a number (1.2). Lacking an operator, the parser aborts. On the other hand, this works fine: </p><pre class="fragment">twoN constrained twoNxy=1e4 -Txy  # OK
</pre><p> Because "-Txy" cannot be interpreted as a literal number, legofit treats it as an operator (-) followed by a variable name.</p>
<p >All types of parameter can be used in constraint equation. Independent variables must be declared in the .lgo file before they are used in a constraint equation. The parser can recognize complex mathematical expressions and knows about the standard mathematical functions. The y'th power of x can be written either as "x^y" or as "pow(x,y)". The natural log can be written either as "log" or as "ln". Parentheses are allowed, and operators have the usual precedence. For example, the following lines are equivalent: </p><pre class="fragment">twoN constrained x=exp(a)*pow(b,y)
twoN constrained x=e^a*b^y
twoN constrained x=exp(a + y*log(b))
</pre><p> To spread a constraint across several lines, break the line after a binary operator ("+", "-", "*", or "/"). For example, </p><pre class="fragment">twoN constrained twoNxy=1e4 -
  1.2*Txy +
  0.01*Txy*Txyn # Constraint spread across 3 lines.
</pre><p> Although the constraint syntax is very flexible, we don't recommend using all this flexibility. It's best to define constrained variables as linear functions of principal components. The principal components are then defined as free variables, and all other variables are either fixed or are linear functions of principal components. The <a class="el" href="pclgo.html">pclgo</a> program can be used to rewrite a <code>.lgo</code> file in this fashion.</p>
<p >We have one more variable to declare: </p><pre class="fragment">mixFrac free  mN=0.02           # Neanderthal admixture into y
</pre><p> The "mixFrac" command declares a "mixture fraction"&mdash;the fraction of a some population that derives from introgression. As above, it could have been fixed or constrained.</p>
<p >The next few lines of the input file declare the segments of the population network. The first of these is </p><pre class="fragment">segment x     t=zero   twoN=one    samples=1  # Africa
</pre><p> Here, "x" is the name of the segment, "zero" is the time at which it ends, and "one" is the population size. Note that "zero" and "one" are variables that we declared above. The "samples=1" phrase says that there is a genetic sample from the end of this segment. In other words, the date of the sample is "t=zero". If the segment has no samples, you can omit "samples=0". It is also possible to specify more than one sample, as in "samples=2". If you do this, the program will generate more complex site patterns, whose frequencies will depend on recent population size. In this situation, you would not want to set "twoN=one".</p>
<p >The next two lines are similar, and define two other terminal populations: </p><pre class="fragment">segment y     t=zero   twoN=one    samples=1  # Eurasia
segment n     t=Tn     twoN=twoNn  samples=1  # Neanderthal
</pre><p> <a class="el" href="struct_segment.html">Segment</a> "n" does not end at time zero, but rather at the time, Tn, of Neanderthal admixture. It has one sample, whose date is also Tn. This is a bit of a stretch, because it assumes that the Neanderthal genome lived at the same time as the episode of admixture. I make this assumption for simplicity&mdash;this is only an example. There are 3 more segments to declare: </p><pre class="fragment">segment y2    t=Tn     twoN=one               # pre-mig eurasia
segment xy    t=Txy    twoN=twoNxy            # early modern
segment xyn   t=Txyn   twoN=twoNn             # ancestral
</pre><p> These segments don't have a "samples" component, because none of them have genetic samples. <a class="el" href="struct_segment.html">Segment</a> y2 represents the Eurasian population before the episode of admixture. Note that it ends at the same time as segment n. This is necessary, because we will want to mix y2 and n below to model gene flow. Also note that the size of xyn equals twoNn&mdash;the same variable we used in setting the size of segment n. This establishes a constraint: the sizes of XYN and N will always be equal, no matter how the optimizer adjusts the value of twoNn.</p>
<p >The rest of the .lgo file defines relationships between segments. This involves two statements: "mix" and "derive". Consider the mix statement first: </p><pre class="fragment">mix    y  from y2 + mN * n      # y is a mixture of y2 and n
</pre><p> This says that y is a mixture of y2 and n, which must end at the same date. Specifically, a fraction mN of y comes from n and the remaining fraction comes from y2. Finally, we have 4 examples of the "derive" statement: </p><pre class="fragment">derive x  from xy               # x is child of xy
derive y2 from xy               # y2 is child of xy
derive xy from xyn              # xy is child of xyn
derive n  from xyn              # n is child of xyn
</pre><p> These statements establish ancestor-descendant relationships between segments. Note that x and y2 both derive from xy, so xy has two "children", but x and y2 each have only one parent. On the other hand, segment y has two parents, as defined in the "mix" statement above.</p>
<p >Segments cannot have more than two parents or more than two children. All segments should descend, eventually, from a single root.</p>
<p >The site patterns printed refer only to the segments that contain samples, and the sort order of site patterns is determined by the order in which segments are listed in the .lgo file. In the file discussed above, there are three segments with samples, and these are in order "x", "y", "n". For this reason, the output will contain a site pattern labeled "x:y:n" rather than, say, "x:n:y".</p>
<p >Using this .lgo file as input, <code>legosim -i 10000</code> produces </p><pre class="fragment">############################################################
# legosim: generate site patterns by coalescent simulation #
############################################################

# Program was compiled: Jun  8 2017 12:41:14
# Program was run: Tue Jul 11 09:18:00 2017

# cmd: legosim -i 10000 input.lgo
# nreps                       : 10000
# input file                  : input.lgo
# not simulating mutations
# excluding singleton site patterns.
#       SitePat E[BranchLength]
            x:y   17493.5768947
            x:n       5.7110115
            y:n     467.3607849
</pre><p> The program reports the mean branch length in generations of three site patterns. For example, "x:y" refers to the pattern in which the derived allele is present in the samples x and y but not in n. The 2nd column gives the expected length in generations of the branch on which mutations would generate the corresponding site pattern.</p>
<p >In the example above, we saw parameters of three types: "twoN", "time", and "mixFrac". There is also a 4th type of variable, which is declared with the "param" command, and which is intended to represent quantities that are neither times, population sizes, nor admixture fractions. Here's an example, which also illustrates the how ranges can be specified for free parameters. </p><pre class="fragment">param free [ 0, 2] msum = 0.02  # mN + mD
param free [-1, 1] mdif = 0.0   # mN - mD
mixFrac constrained  mN = 0.5*(msum + mdif)
mixFrac constrained  mD = 0.5*(msum - mdif)
</pre><p> Here <code>msum</code> is the sum of two admixture fractions and <code>mdif</code> is the difference between them. We defined the parameters this way, because <code>mN</code> and <code>mD</code> were tightly correlated, but <code>msum</code> and <code>mdif</code> were nearly uncorrelated. This allowed the optimization algorithm to work with the uncorrelated pair of parameters rather than the correlated pair.</p>
<p >In the declaration of <code>msum</code>, "[0, 2]" specifies the range of this parameter. Ranges are used in initializing the random swarm of points used by the differential evolution algorithm. Initial points are randomly distributed within the range. A range can be specified for any free parameter, not just those defined with the <code>param</code> command. If no range is provided, legofit uses default ranges that differ, depending on the type of parameter. The default range is [1, 1e7] for <code>twoN</code> parameters, [0, 1e7] for <code>time</code> parameters, [0, 1] for <code>mixFrac</code> parameters, and [-<code>DBL_MAX</code>, <code>DBL_MAX</code>] for <code>param</code> parameters.</p>
<h1><a class="anchor" id="modsel"></a>
Model selection</h1>
<p >In fitting models to data, it is important to avoid "overfitting". Complex models generally fit the data set better than simple ones do, but this improvement may be illusory. As models increase in complexity, we are eventually fitting the noise in the data rather than the signal. Consequently, the complex model may do a poor job of predicting new observations, which were not used to fit the model in the first place. Methods of model selection aim to penalize overly-complex models, so that the preferred model is the one that is best at predicting new observations.</p>
<p >The legofit package provides two methods of model selection:</p>
<ul>
<li><a class="el" href="bepe.html">bepe</a>, implements the "bootstrap estimate of prediction
  accuracy" (Efron and Tibshirani, 1993, sec. 17.6).</li>
<li><a class="el" href="clic.html">clic</a>, implements the "composite likelihood information
  criterion" (Varin and Vidoni, 2005).</li>
</ul>
<h1><a class="anchor" id="autotoc_md23"></a>
Using the package</h1>
<h2><a class="anchor" id="autotoc_md24"></a>
Predicting site pattern counts from assumptions about history</h2>
<p >For this purpose, you want to use the program <a class="el" href="legosim.html">legosim</a>. The first step is create a file in <a class="el" href="index.html#lgo">.lgo</a> format, which describes the history of population size, subdivision, and gene flow. This format is described above. Then, you can execute <code>legosim</code> by typing: </p><pre class="fragment">legosim -i 10000 my_input_file.lgo
</pre><p> This uses the stochastic algorithm, which estimates site pattern frequencies by computer simulation. Alternatively, </p><pre class="fragment">legosim -d 0 my_input_file.lgo
</pre><p> would use the deterministic algorithm. See the <a class="el" href="legosim.html">legosim</a> documentation for details about this algorithm.</p>
<p >See the <a class="el" href="legosim.html">legosim</a> documentation for details.</p>
<h2><a class="anchor" id="autotoc_md25"></a>
Simulating site patterns</h2>
<p >The package provides support for tabulating site patterns from several coalescent simulators. To study the output of <a href="http://home.uchicago.edu/rhudson1/source/mksamples.html">ms</a>, pipe the results through <a class="el" href="ms2sim.html">ms2sim</a> and then <a class="el" href="simpat.html">simpat</a>. For <a href="https://scrm.github.io">scrm</a>, use the <code>-transpose-segsites</code> option, and pipe the output through <a class="el" href="scrmpat.html">scrmpat</a>. The authors of <a href="https://github.com/tskit-dev/msprime">msprime</a> recommend running their software within a Python script. Within such a script, it is easy to generate output in the form required by <a class="el" href="simpat.html">simpat</a>.</p>
<p >For less sophisticated simulations, use the <code>-U</code> option of <a class="el" href="legosim.html">legosim</a>. This assumes free recombination between nucleotide sites and generates site pattern frequencies with unrealistically narrow sampling distributions.</p>
<h2><a class="anchor" id="autotoc_md26"></a>
Estimating parameters from genetic data</h2>
<p >This involves several programs. The first step is to generate input files in ".daf" or ".raf" format, as described above. You will need one .daf or .raf file for each population. For .raf, you will in addition need a .raf file for an outgroup population. See the documentation of <a class="el" href="index.html#daf">daf</a> and <a class="el" href="index.html#raf">raf</a> for details.</p>
<p >The next task is to tabulate site pattern counts. For details, see <a class="el" href="tabpat.html">tabpat</a> or <a class="el" href="sitepat.html">sitepat</a>. Either of these programs will generate a small text file, with one row for each site pattern. If there are 4 populations in the analysis, there will be 10 site patterns.</p>
<p >You will also need a .lgo file, which describes the model of history you wish to explore. It also specifies which parameters will be estimated. Details are above.</p>
<p >Finally, <a class="el" href="legofit.html">legofit</a> will estimate parameters. This program may take several hours to run, depending on the size of the analysis and on whether you are using the default stochastic algorithm or the deterministic one, which is invoked by the command-line option <code>-d 0</code>.</p>
<p >To generate a bootstrap confidence interval, use the <code>--bootreps</code> option of <a class="el" href="tabpat.html">tabpat</a> or <a class="el" href="sitepat.html">sitepat</a>. This will generate not only the primary output (written to standard output), but also an additional output file for each bootstrap replicate. For example, <code>--bootreps 50</code> would generate 51 output files: 1 for the normal output, and 1 for each bootstrap replicate.</p>
<p >These files should each be analyzed with a separate run of <code>legofit</code>. If you have access to a compute cluster, these jobs can be run in parallel.</p>
<p >You might be tempted to parallelize these legofit jobs on a single computer, using multiple threads of execution. Don't do it. A single legofit job makes use of all available threads, so nothing is gained by launching simultaneous legofit jobs on a single computer. Unless you have access to a compute cluster, legofit jobs should be run sequentially. As each job can take several hours, a full bootstrap may take several days.</p>
<p >Having run <code>legofit</code> on the real data and all bootstrap replicates, you can use <a class="el" href="bootci.html">bootci.py</a> and <a class="el" href="flatfile.html">flatfile.py</a> to summarize the information in the resulting output files.</p>
<p >Finally, <a class="el" href="diverg.html">diverg.py</a> can be used for comparing two sets of site-pattern counts or frequencies. It uses the Kullback-Leibler (KL) divergence to measure the discrepancy between the two distributions. It provides not only the overall KL divergence but also the contribution of each site pattern. Thus, it will tell you which site patterns are responsible for a poor fit between observed and expected site pattern frequencies.</p>
<p >A typical legofit analysis involves several stages:</p>
<ol type="1">
<li>Write a .lgo file describing the model of interest. Let us call this file a.lgo. The value of one time parameter must be specified as a fixed parameter in order to calibrate the molecular clock. If singletons are excluded (the default) two time parameters must be fixed in order to specify the length of an interval. It may be possible to fix some additional parameters, if their values do not affect site pattern frequencies. (More on this below.) But in general, you want most variables to be free in this initial model to avoid introducing bias. Run legofit on the real data and each bootstrap replicate, using the <code>--stateOut</code> option. I'll assume that the results are in files named a1.legofit (estimates from the real data), a1.state (<code>--stateOut</code> file for the real data), a1boot0.legofit (estimates from 0'th bootstrap replicate), a1boot0.state (<code>--stateOut</code> file for this replicate), and so on. The command for bootstrap replicate 2 might look like this: <pre class="fragment">
legofit -1 --tol 3e-5 -S 5000@10000 -S 1000@100000 -S 1000@1000000 \
--stateOut a1boot2.state a.lgo boot2.opf &gt; a1boot2.legofit
</pre> for the stochastic algorithm, or like this: <pre class="fragment">
legofit -1 -d 0 --tol 3e-6 -S 5000 \
--stateOut a1boot2.state a.lgo boot2.opf &gt; a1boot2.legofit
</pre> for the deterministic one. Here <code>boot2.opf</code> is the data file for bootstrap replicate 2. This will generate two output files: a1boot2.legofit will contain the estimates from bootstrap replicate 2 in stage 1 of the analysis. a1boot2.state is the corresponding state file.</li>
<li>In a complex model, there may be multiple local optima. If so, the various .legofit files may be scattered among these optima. To address this problem, restart legofit for each data file, using the <code>--stateIn</code> option multiple times. For example: <pre class="fragment">
legofit -1 --tol 2e-5 -S 1000@2000000 a.lgo boot2.opf \
  --stateIn a1.state \
  --stateIn a1boot0.state \
  --stateIn a1boot1.state \
  --stateIn a1boot2.state \
  ...
  --stateIn a1boot49.statep &gt; a2boot2.legofit
</pre> The <code>--stateIn</code> argument has been used here 51 times: once for the real data and once for each of the 50 bootstrap replicates. This re-starts the optimizer with an initial swarm of points that is spread across all the local optima found during stage 1 of the analysis. Legofit is then able to choose among local optima.</li>
<li>Use pclgo to re-express the free variables of a.lgo in terms of principal components. Optionally, you can use the <code>--tol</code> argument of pclgo to reduce the dimension of the parameter space. See the <a class="el" href="pclgo.html">pclgo</a> page for instructions on using this program to construct a new file&ndash;let's call it b.lgo&ndash;in which all free variables are principal components. Repeat stages 1 and 2 for this new .lgo file.</li>
</ol>
<p >I mentioned above that some variables do not affect site pattern frequencies. As an example, consider the case in which there is a single modern sample from population Y, a single ancient sample from Z, and there is gene flow from Z into Y. If the gene flow is more recent than the ancient sample, its timing will not affect site pattern frequencies. The time of admixture should therefore be declared as a fixed variable with an arbitrary value in the .lgo file.</p>
<h2><a class="anchor" id="autotoc_md27"></a>
Sort order of site patterns</h2>
<p >The sort order of site patterns is determined by the order of command line arguments to <a class="el" href="tabpat.html">tabpat</a> and <a class="el" href="sitepat.html">sitepat</a>, and by the order in which segments are defined in the .lgo file. For example, if "x" precedes "y", then we get a site pattern labeled "xy" rather than "yx". These inputs should be ordered consistently in tabpat, sitepat, and .lgo, for otherwise it will be hard to compare observed site pattern frequencies with those predicted by <a class="el" href="legosim.html">legosim</a> or <a class="el" href="legofit.html">legofit</a>. I recommend arranging them in the order that populations labels appear in your figures.</p>
<h1><a class="anchor" id="autotoc_md28"></a>
Bias in legofit</h1>
<h2><a class="anchor" id="autotoc_md29"></a>
Biases arising from constraints</h2>
<p >Biases arise in <code>legofit</code> because of the constraint that a child population cannot be older than its parent. If the parent's age is fixed, then it represents an inequality constraint on the age of the child. If the child is only slightly younger than the parent, the optimizer has problems. It will propose new values for the child's age. Those that increase the child's age will be rejected if they violate the inequality constraint. Those that decrease the child's age do not encounter this constraint. Consequently, the optimizer is more likely to move away from the constraint rather than toward it. This biases estimates away from the constraint, whenever the true value is close to the constraint.</p>
<p >The magnitude of this bias depends on the spread of the sampling distribution of the child's age. If that sampling distribution is wide, then the DE algorithm will tend to take large steps and will encounter the boundary constraint sooner. This generates a large bias. If the sampling distribution is narrow, the bias is small.</p>
<h2><a class="anchor" id="autotoc_md30"></a>
Bias arising from selection of variant sites</h2>
<p >Genetic data are often restricted to sites that are polymorphic within some group of samples. For example, the 1000-Genomes Project distributes files containing genotypes that are polymorphic within modern humans. These data do not include sites at which the derived allele is present only in Neanderthals and/or Denisovans. An analysis using such data would be biased, because it would undercount the corresponding site patterns.</p>
<p >To avoid this bias, it is best to work with complete genomes rather than just the variant sites. Alternatively, one could call variant sites jointly using all genomes to be included in the analysis.</p>
<h2><a class="anchor" id="autotoc_md31"></a>
Bias arising from identifiability problems</h2>
<p >It is often the case that many sets of parameter values imply the same site pattern frequencies. Ideally this merely broadens confidence intervals and does not introduce bias. It can, however, introduce bias. For this reason, one should always check for bias after a model has been fit. To check for bias, I use <a href="https://github.com/tskit-dev/msprime">msprime</a> to simulate 50 data sets, using the model of history implied by the fitted parameter values. Then analyze these as though they were real data. If the resulting estimates are scattered around the fitted parameter value, then there is no substantial bias. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Feb 1 2023 15:17:26 for Legofit by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
